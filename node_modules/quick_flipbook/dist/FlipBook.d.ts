import * as THREE from 'three';
import { FlipPage } from './FlipPage';
export type FlipBookConfig = {
    /**
     * Duration of the flip animation in seconds
     */
    flipDuration: number;
    /**
     * vertical spece between the stacked pages
     */
    yBetweenPages: number;
    /**
     * How much to subdivide the page's plane
     */
    pageSubdivisions: number;
};
type PageSource = String | THREE.Material | THREE.Texture | null;
export declare class FlipBook extends THREE.Mesh implements Iterable<FlipPage> {
    /**
     * Sheets of paper (each FlipPage holds 2 "pages")
     */
    private pages;
    private pool;
    private readonly _url2Loader;
    private readonly _pageSubdivisions;
    private _currentProgress;
    private _goalProgress;
    private _currentPage;
    private readonly _flipDuration;
    private _stepSize;
    private _flipDirection;
    private readonly _ySpacing;
    constructor(config: FlipBookConfig | null);
    [Symbol.iterator](): Iterator<FlipPage>;
    /**
     * Initialize the book. Pass in the URLs to the images to use for each page.
     * The order in which they will be loaded is one page (2 images per page) at a time.
     * After one page is loaded, the next will start loading. While one page is loading the rest are in perpetual inactive state (nothing loading)
      
     * @param pagesSources Array with the "source" to use as the page texture, either a material or a url to load an image from.
     */
    setPages(pagesSources: PageSource[]): void;
    /**
     * Returns the total number of pages.
     * **Do not confuse with the number of sheets of paper**
     */
    get totalPages(): number;
    /**
     * Loads the 2 faces of a page at the same time...
     */
    private loadPages;
    /**
     * Loads a page's face. If it is a Material it just puts that, if it is a string it will try to load it using the TextureLoader
     */
    private loadPage;
    private textureToMaterial;
    /**
     * The current "page" (as you would read on a book, the page number...)
     */
    get currentPage(): number;
    set currentPage(n: number);
    /**
     * Each page has a progress that goes form 0 to 1.
     * Here, the progress of a book goes form 0 to `Total Pages` (but in this case, by "page" we mean paper, a paper has 2 pages, the fornt and back page...)
     * and the decimal portion is the progress of the flip of that page.
     * If you have 3 pages, for example, to send the user to the last page's back side, you have to call .progress = 3 (which is almost equivalent to 2.9999... )
     *
     * expects a number from `0` to `book.totalPages/2`
     */
    get progress(): number;
    set progress(p: number);
    /**
     * Call this to animate this book every frame.
     * @param delta seconds since last frame render
     */
    animate(delta: number): void;
    /**
     * It will flip all the pages until this page is facing at the user.
     * @param page Page of interest
     */
    flipPage(page: FlipPage): void;
    /**
     * Send the book to the next page
     */
    nextPage(): void;
    /**
     * Send the book to the previous page
     */
    previousPage(): void;
    /**
     * Goes one by one and calculate the progress of each FlipPage based on the progress of the book.
     */
    private flipPages;
    /**
     * Will dispose the book, the pages and all the materials used. Also the internal cache.
     */
    dispose(): void;
}
export {};
