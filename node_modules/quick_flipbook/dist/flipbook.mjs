import * as h from "three";
import { mergeGeometries as _ } from "three/examples/jsm/utils/BufferGeometryUtils.js";
import * as n from "three.modifiers";
import { UserDefined as m, ModConstant as c } from "three.modifiers";
class w extends m {
  /** 
   * @param elevationAxis Axis to use as elevation dimension
   * @param alongAxis Axis to use as the "plane" (perpendicular to elevation ideally)
   * @param effectRange from 0 to 1, along the "along axis" what portion wil be subjected to this effect. 
   * @param effectMid from 0 to 1, at what point we stop climbing up and start going down again?
   * @param elevationHeight how "high" we elevate the vertices along the elevationAxis?
   */
  constructor(t = c.Y, e = c.X, s = 0.5, i = 0.5, r = 0.5) {
    super(), this.elevationAxis = t, this.alongAxis = e, this.effectRange = s, this.effectMid = i, this.elevationHeight = r, this.intensity = 1, this.renderVector = this._renderVector;
  }
  _renderVector(t, e, s) {
    let i = t.getRatio(this.alongAxis), r = t.getValue(this.elevationAxis);
    if (i <= this.effectRange) {
      i /= this.effectRange;
      let a = 0;
      i < this.effectMid ? (i = i / this.effectMid, a = Math.sqrt(1 - Math.pow(i, 2) + i * 2 - 1)) : (i = (i - this.effectMid) / (1 - this.effectMid), a = (Math.cos(i * Math.PI) - -1) / 2), t.setValue(this.elevationAxis, r + a * this.elevationHeight * this.intensity);
    }
  }
}
const d = (o) => {
  for (var t = o.attributes.uv, e = 0; e < t.count; e++) {
    var s = t.getX(e), i = t.getY(e);
    t.setXY(e, 1 - s, i);
  }
  return o;
}, g = new h.MeshStandardMaterial({ color: "#ffffff" });
class v extends h.Mesh {
  constructor(t = 10) {
    super();
    let e = new h.Mesh(
      _(
        [
          d(new h.PlaneGeometry(1, 1, t, t)),
          d(new h.PlaneGeometry(1, 1, t, t).rotateY(Math.PI))
        ],
        !0
        // allow groups
      ),
      [
        g,
        g
      ]
    );
    e.castShadow = !0, e.receiveShadow = !0, e.rotateX(Math.PI / 2), e.position.x = 0.5, this.scale.z = -1, this.add(e), this.page = e, this.modifiers = new n.ModifierStack(e), this.bend = new n.Bend(0, 0, 0), this.bend.constraint = n.ModConstant.LEFT, this.twist = new n.Twist(0), this.twist.vector = new n.Vector3(2, 0, 0), this.twist.center = new n.Vector3(-0.5, 0, 0), this.pageCurve = new w(
      n.ModConstant.Z,
      n.ModConstant.X,
      0.812,
      0.325,
      0.054
    ), this.modifiers.addModifier(this.pageCurve), this.modifiers.addModifier(this.bend), this.modifiers.addModifier(this.twist);
  }
  /**
   * Sets the material for a page's face.
   * @param newMaterial New material for this page's face.
   * @param index 0 or 1
   */
  setPageMaterial(t, e) {
    this.page.material[e] = t;
  }
  /**
   * Sets the internal progress of the flip of this page. 0 = no flip. 1 = fully flipped to the otehr side.
   * @param progress a number from 0 to 1
   * @param direction either -1 or 1 to know to which side we are flipping (this is used to invert the bending of the page to the correct side on flip)
   * @param pageCurveIntensity Intensity of the page curve modifier effect
   */
  flip(t, e, s = 1) {
    this.rotation.z = Math.PI * t, this.bend.force = Math.min(-Math.sin(this.rotation.z) / 2, -1e-4) * e, this.twist.angle = Math.sin(this.rotation.z) / 10, this.pageCurve.intensity = (-1 + 2 * t) * (-Math.sin(this.rotation.z) + 1) * s, this.modifiers.apply();
  }
  /**
   * call dispose on the material of this face.
   */
  disposeMaterial(t) {
    const e = this.page.material[t];
    e !== g && e.dispose();
  }
  /**
   * Just sets all materials to "no texture"
   */
  reset() {
    this.setPageMaterial(g, 0), this.setPageMaterial(g, 1);
  }
  dispose(t = !1) {
    t && (this.disposeMaterial(0), this.disposeMaterial(1)), this.page.geometry.dispose(), this.modifiers.destroy();
  }
}
const u = /* @__PURE__ */ function() {
  var o;
  return () => {
    if (!o) {
      const t = document.createElement("canvas");
      t.width = 256, t.height = 256;
      const e = t.getContext("2d"), s = e.createLinearGradient(0, 0, t.width, 0);
      s.addColorStop(0, "black"), s.addColorStop(0.1, "white"), e.fillStyle = s, e.fillRect(0, 0, t.width, t.height), o = new h.CanvasTexture(t), t.remove();
    }
    return o;
  };
}();
class y extends h.Mesh {
  constructor(t) {
    super(), this.pages = [], this.pool = [], this._url2Loader = /* @__PURE__ */ new Map(), this._currentProgress = 0, this._flipDuration = (t == null ? void 0 : t.flipDuration) || 1, this._ySpacing = (t == null ? void 0 : t.yBetweenPages) || 1e-3, this._pageSubdivisions = (t == null ? void 0 : t.pageSubdivisions) || 20, this.currentPage = 0;
  }
  [Symbol.iterator]() {
    let t = 0;
    return {
      next: () => t < this.pages.length ? { value: this.pages[t++], done: !1 } : { value: null, done: !0 }
    };
  }
  /** 
   * Initialize the book. Pass in the URLs to the images to use for each page.
   * The order in which they will be loaded is one page (2 images per page) at a time.
   * After one page is loaded, the next will start loading. While one page is loading the rest are in perpetual inactive state (nothing loading) 
    
   * @param pagesSources Array with the "source" to use as the page texture, either a material or a url to load an image from.
   */
  setPages(t) {
    for (t.length % 2 !== 0 && t.push(""); this.pages.length; ) {
      let s = this.pages.pop();
      s.reset(), this.pool.push(s), this.remove(s);
    }
    let e = Promise.resolve();
    for (let s = 0; s < t.length; s += 2) {
      const i = t[s], r = t[s + 1];
      let a = this.pool.pop();
      a || (a = new v(this._pageSubdivisions)), this.add(a), a.position.y = -this._ySpacing * this.pages.length, this.pages.push(a), a.name = `Page#${this.pages.length}`, e = e.then(this.loadPages(i, r, a));
    }
    this.currentPage > this.pages.length * 2 - 1 && (this._currentPage = this.pages.length * 2 - 1, this._currentProgress = this.pages.length), this.flipPages();
  }
  /**
   * Returns the total number of pages.
   * **Do not confuse with the number of sheets of paper**
   */
  get totalPages() {
    return this.pages.length * 2;
  }
  /**
   * Loads the 2 faces of a page at the same time...
   */
  loadPages(t, e, s) {
    return () => Promise.all([
      this.loadPage(t, 1, s),
      this.loadPage(e, 0, s)
    ]);
  }
  /**
   * Loads a page's face. If it is a Material it just puts that, if it is a string it will try to load it using the TextureLoader
   */
  loadPage(t, e, s) {
    if (!t || t === "") {
      const r = new h.MeshStandardMaterial({
        color: "white",
        roughness: 0.2,
        aoMapIntensity: 0.7,
        aoMap: e == 1 ? u() : null
      });
      return s.setPageMaterial(r, e), Promise.resolve();
    }
    if (t instanceof h.Material)
      return s.setPageMaterial(t, e), Promise.resolve();
    if (t instanceof h.Texture)
      return s.setPageMaterial(this.textureToMaterial(t, e), e), Promise.resolve();
    const i = t;
    return this._url2Loader.has(i) || this._url2Loader.set(i, new Promise((r, a) => {
      new h.TextureLoader().load(
        t,
        (l) => {
          r(this.textureToMaterial(l, e));
        },
        void 0,
        (l) => {
          r(null);
        }
      );
    })), this._url2Loader.get(i).then((r) => {
      s.setPageMaterial(r, e);
    });
  }
  textureToMaterial(t, e) {
    return t.magFilter = h.LinearFilter, t.minFilter = h.LinearFilter, t.generateMipmaps = !1, t.colorSpace = h.SRGBColorSpace, new h.MeshStandardMaterial({
      color: "white",
      map: t,
      roughness: 0.2,
      aoMapIntensity: 0.7,
      aoMap: e == 1 ? u() : null,
      toneMapped: !1
    });
  }
  /**
   * The current "page" (as you would read on a book, the page number...)
   */
  get currentPage() {
    return this._currentPage;
  }
  set currentPage(t) {
    let e = Math.ceil(t / 2), s = e - this._currentProgress;
    this._stepSize = s / this._flipDuration, this._flipDirection = this._stepSize > 0 ? 1 : -1, this._currentPage = Math.ceil(t), this._goalProgress = e, this.flipPages();
  }
  /**
   * Each page has a progress that goes form 0 to 1. 
   * Here, the progress of a book goes form 0 to `Total Pages` (but in this case, by "page" we mean paper, a paper has 2 pages, the fornt and back page...)
   * and the decimal portion is the progress of the flip of that page. 
   * If you have 3 pages, for example, to send the user to the last page's back side, you have to call .progress = 3 (which is almost equivalent to 2.9999... )
   * 
   * expects a number from `0` to `book.totalPages/2`
   */
  get progress() {
    return this._currentProgress;
  }
  set progress(t) {
    let e = this._currentProgress;
    this._currentProgress = Math.max(0, Math.min(t, this.pages.length)), this._currentPage = Math.floor(this._currentProgress * 2), this._stepSize = 0, this._flipDirection = this._currentProgress > e ? 1 : -1, this.flipPages();
  }
  /**
   * Call this to animate this book every frame.
   * @param delta seconds since last frame render
   */
  animate(t) {
    this._stepSize != 0 && (this._currentProgress += this._stepSize * t, (this._stepSize > 0 && this._currentProgress > this._goalProgress || this._stepSize < 0 && this._currentProgress < this._goalProgress) && (this._currentProgress = this._goalProgress, this._stepSize = 0), this.flipPages());
  }
  /**
   * It will flip all the pages until this page is facing at the user.
   * @param page Page of interest
   */
  flipPage(t) {
    var e = this.pages.indexOf(t);
    if (e < 0)
      throw new ReferenceError("I don't own that page! Not mine!");
    const s = e * 2, i = s + 1;
    this.currentPage = this._currentPage <= s ? i : s;
  }
  /**
   * Send the book to the next page
   */
  nextPage() {
    this.currentPage = Math.min(Math.ceil(this.currentPage / 2) + 1, this.pages.length) * 2;
  }
  /**
   * Send the book to the previous page
   */
  previousPage() {
    this.currentPage = Math.max(Math.ceil(this.currentPage / 2) - 1, 0) * 2;
  }
  /**
   * Goes one by one and calculate the progress of each FlipPage based on the progress of the book.
   */
  flipPages() {
    const t = this.pages.length;
    let e = this._currentProgress % 1, s = Math.floor(this._currentProgress);
    for (let r = 0; r < t; r++) {
      const a = this.pages[r], l = s < r ? 0 : s > r ? 1 : e, P = l < 0.5 ? 0 : (l - 0.5) / 0.5, f = -this._ySpacing * (t - r), p = -this._ySpacing * r, M = this._currentProgress < 1 ? e : this._currentProgress >= t ? 0 : this._currentProgress >= t - 1 ? 1 - e : 1;
      a.flip(l, this._flipDirection, M), a.position.y = p + P * (f - p);
    }
    const i = s == 0 ? -0.5 + 0.5 * e : s == t - 1 ? 0.5 * e : s == t ? 0.5 : 0;
    this.position.x = i * this.scale.x;
  }
  /**
   * Will dispose the book, the pages and all the materials used. Also the internal cache.
   */
  dispose() {
    for (; this.pages.length; ) {
      let t = this.pages.pop();
      this.remove(t);
    }
    for (; this.pool.length; )
      this.pool.pop().dispose(!0);
    this._url2Loader.forEach((t) => t.then((e) => e.dispose())), this._url2Loader.clear();
  }
}
export {
  y as FlipBook
};
